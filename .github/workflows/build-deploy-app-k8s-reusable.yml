name: Build and Deploy App to K8s (Reusable)

# ⚠️ 此工作流是可复用的，不会自动触发
# - 只能通过其他工作流调用（workflow_call）
# - 用于构建应用并立即部署到 Kubernetes 集群
# - 每个应用独立完成构建→部署流程，不等待其他应用

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Application name (e.g., system-app, admin-app)'
        required: true
        type: string
      registry:
        description: 'Container registry URL'
        required: true
        type: string
      github_repository:
        description: 'GitHub repository name'
        required: true
        type: string
      github_sha:
        description: 'GitHub commit SHA'
        required: true
        type: string
      github_repository_owner:
        description: 'GitHub repository owner (lowercase)'
        required: true
        type: string
      image_tag:
        description: 'Docker image tag (e.g., commit SHA short)'
        required: true
        type: string
      k8s_namespace:
        description: 'K8s namespace (default: btc-shopflow)'
        required: false
        type: string
        default: 'btc-shopflow'
      skip_build:
        description: 'Skip build step'
        required: false
        type: boolean
        default: false
      skip_deploy:
        description: 'Skip deploy step'
        required: false
        type: boolean
        default: false
    secrets:
      gh_token:
        description: 'GitHub token for registry access'
        required: true
      K8S_SERVER:
        required: false
      K8S_CA_CERT:
        required: false
      K8S_TOKEN:
        required: false

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  build-and-deploy:
    name: Build and Deploy ${{ inputs.app_name }}
    runs-on: ubuntu-latest
    
    steps:
      # ========== 构建阶段 ==========
      - name: Checkout code
        uses: actions/checkout@v4
      
      # ========== 构建阶段（仅在未跳过时执行）==========
      - name: Setup Node.js
        if: inputs.skip_build != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        if: inputs.skip_build != 'true'
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        if: inputs.skip_build != 'true'
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        if: inputs.skip_build != 'true'
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        if: inputs.skip_build != 'true'
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        if: inputs.skip_build != 'true'
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ inputs.github_sha }}
          restore-keys: |
            packages-build-
      
      - name: Build dependencies if needed
        if: inputs.skip_build != 'true'
        run: |
          if [ ! -d "packages/vite-plugin/dist" ] || [ ! -f "packages/vite-plugin/dist/index.js" ]; then
            echo "Building dependencies for ${{ inputs.app_name }}..."
            pnpm --filter @btc/vite-plugin run build
            pnpm --filter @btc/shared-utils run build
            pnpm --filter @btc/shared-core run build
            pnpm --filter @btc/shared-components run build
            pnpm --filter @btc/subapp-manifests run build
          else
            echo "Using cached built packages"
          fi
      
      - name: Build application
        if: inputs.skip_build != 'true'
        run: cd apps/${{ inputs.app_name }} && pnpm run build
      
      - name: Skip build (placeholder)
        if: inputs.skip_build == 'true'
        run: echo "⏭️  跳过构建步骤（使用已有镜像）"
      
      # ========== Docker 构建和推送（仅在未跳过构建时执行）==========
      - name: Validate GitHub Token
        if: inputs.skip_build != 'true'
        run: |
          echo "Validating GitHub token for registry access..."
          # 优先使用传入的 gh_token，如果为空或未定义则使用 github.token
          GH_TOKEN="${{ secrets.gh_token }}"
          if [ -n "$GH_TOKEN" ] && [ "$GH_TOKEN" != "" ]; then
            TOKEN="$GH_TOKEN"
            echo "[INFO] Using provided gh_token"
          else
            TOKEN="${{ github.token }}"
            echo "[INFO] Using github.token as fallback"
          fi
          # 最终检查：如果 TOKEN 仍然为空，尝试使用 github.token
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "" ]; then
            TOKEN="${{ github.token }}"
            echo "[INFO] Fallback to github.token"
          fi
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "" ]; then
            echo "[ERROR] No token available"
            echo "[DEBUG] GH_TOKEN value: '${GH_TOKEN:-empty}'"
            echo "[DEBUG] github.token value: '${GITHUB_TOKEN:-empty}'"
            exit 1
          fi
          echo "[SUCCESS] Token is available"
          echo "TOKEN=$TOKEN" >> $GITHUB_ENV
      
      - name: Prepare Docker tags
        if: inputs.skip_build != 'true'
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ inputs.github_repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Login to Container Registry
        if: inputs.skip_build != 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry }}
          username: ${{ github.actor }}
          password: ${{ env.TOKEN }}
      
      - name: Set up Docker Buildx
        if: inputs.skip_build != 'true'
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push Docker image
        if: inputs.skip_build != 'true'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=apps/${{ inputs.app_name }}
          push: true
          tags: |
            ${{ inputs.registry }}/${{ steps.tags.outputs.repository_lower }}/${{ inputs.app_name }}:latest
            ${{ inputs.registry }}/${{ steps.tags.outputs.repository_lower }}/${{ inputs.app_name }}:${{ inputs.github_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      # ========== 部署阶段 ==========
      - name: Setup kubectl
        if: inputs.skip_deploy != 'true'
        uses: azure/setup-kubectl@v3
      
      - name: Skip deploy (placeholder)
        if: inputs.skip_deploy == 'true' || (inputs.skip_deploy != 'true' && steps.configure-k8s.outputs.has_k8s_config == 'false')
        run: |
          if [ "${{ inputs.skip_deploy }}" = "true" ]; then
            echo "⏭️  跳过部署步骤（skip_deploy=true）"
          else
            echo "⏭️  跳过部署步骤（未配置 K8s）"
          fi
      
      - name: Configure K8s
        if: inputs.skip_deploy != 'true'
        id: configure-k8s
        run: |
          # 配置 kubectl（使用 secrets 中的配置）
          if [ -z "${{ secrets.K8S_SERVER }}" ]; then
            echo "⚠️  未配置 K8s 集群信息（K8S_SERVER secret 不存在）"
            echo "跳过 K8s 部署步骤"
            echo ""
            echo "如需部署到 K8s，请在 GitHub Secrets 中配置："
            echo "  - K8S_SERVER: K8s API 服务器地址"
            echo "  - K8S_CA_CERT: CA 证书（base64 编码）"
            echo "  - K8S_TOKEN: 访问令牌"
            echo "has_k8s_config=false" >> $GITHUB_OUTPUT
            echo "has_k8s_config=false" >> $GITHUB_ENV
            exit 0
          fi
          
          echo "has_k8s_config=true" >> $GITHUB_OUTPUT
          echo "has_k8s_config=true" >> $GITHUB_ENV
          
          echo "配置 kubectl..."
          mkdir -p ~/.kube
          cat > ~/.kube/config <<EOF
          apiVersion: v1
          kind: Config
          clusters:
          - cluster:
              server: ${{ secrets.K8S_SERVER }}
              certificate-authority-data: ${{ secrets.K8S_CA_CERT }}
            name: k8s-cluster
          contexts:
          - context:
              cluster: k8s-cluster
              user: k8s-user
            name: k8s-context
          current-context: k8s-context
          users:
          - name: k8s-user
            user:
              token: ${{ secrets.K8S_TOKEN }}
          EOF
          
          # 显式设置 KUBECONFIG 环境变量
          export KUBECONFIG=~/.kube/config
          echo "KUBECONFIG=~/.kube/config" >> $GITHUB_ENV
          echo "has_k8s_config=true" >> $GITHUB_ENV
          
          # 验证配置文件已创建
          if [ ! -f ~/.kube/config ]; then
            echo "❌ kubectl 配置文件创建失败"
            exit 1
          fi
          
          kubectl config use-context k8s-context
          echo "✅ K8s 配置完成"
          
          # 验证 kubectl 连接（不强制要求成功，因为可能是网络问题）
          echo "验证 kubectl 连接..."
          if kubectl cluster-info >/dev/null 2>&1; then
            echo "✅ kubectl 连接正常"
          else
            echo "⚠️  无法连接到集群，但配置已创建（可能是网络问题或集群暂时不可用）"
          fi
      
      - name: Deploy application
        if: inputs.skip_deploy != 'true' && steps.configure-k8s.outputs.has_k8s_config == 'true'
        run: |
          # 确保 kubectl 配置已加载（配置应该在 Configure K8s step 中已创建）
          # 使用 GITHUB_ENV 中的 KUBECONFIG，如果不存在则使用默认路径
          if [ -n "$KUBECONFIG" ]; then
            export KUBECONFIG="$KUBECONFIG"
          else
            export KUBECONFIG=~/.kube/config
          fi
          
          # 验证 kubectl 配置
          if [ ! -f "$KUBECONFIG" ]; then
            echo "❌ kubectl 配置不存在: $KUBECONFIG"
            echo "请确保 Configure K8s step 已成功执行"
            echo "检查文件是否存在:"
            ls -la ~/.kube/ || echo "~/.kube 目录不存在"
            exit 1
          fi
          
          echo "✅ 使用 kubectl 配置: $KUBECONFIG"
          
          # 验证 kubectl 可以连接到集群（不强制要求成功）
          echo "验证 kubectl 连接..."
          if kubectl cluster-info >/dev/null 2>&1; then
            echo "✅ kubectl 连接正常"
          else
            echo "⚠️  kubectl 无法连接到集群，但继续尝试部署（可能是网络问题）"
          fi
          
          APP_NAME="${{ inputs.app_name }}"
          IMAGE_TAG="${{ inputs.image_tag }}"
          REGISTRY="${{ inputs.registry }}"
          REPO_OWNER="${{ inputs.github_repository_owner }}"
          K8S_NAMESPACE="${{ inputs.k8s_namespace }}"
          
          # 应用名称到 Deployment 名称的映射
          declare -A DEPLOYMENT_NAMES=(
            ["system-app"]="btc-system-app"
            ["admin-app"]="btc-admin-app"
            ["logistics-app"]="btc-logistics-app"
            ["quality-app"]="btc-quality-app"
            ["production-app"]="btc-production-app"
            ["engineering-app"]="btc-engineering-app"
            ["finance-app"]="btc-finance-app"
            ["mobile-app"]="btc-mobile-app"
          )
          
          DEPLOYMENT_NAME="${DEPLOYMENT_NAMES[$APP_NAME]}"
          FULL_IMAGE_TAG="$REGISTRY/$REPO_OWNER/$APP_NAME:$IMAGE_TAG"
          
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "🚀 部署应用: $APP_NAME"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Deployment: $DEPLOYMENT_NAME"
          echo "镜像: $FULL_IMAGE_TAG"
          echo "命名空间: $K8S_NAMESPACE"
          
          # 检查 Deployment 是否存在
          if kubectl get deployment "$DEPLOYMENT_NAME" -n "$K8S_NAMESPACE" >/dev/null 2>&1; then
            echo "✅ 更新现有 Deployment..."
            kubectl set image deployment/"$DEPLOYMENT_NAME" "$APP_NAME=$FULL_IMAGE_TAG" -n "$K8S_NAMESPACE"
            kubectl rollout status deployment/"$DEPLOYMENT_NAME" -n "$K8S_NAMESPACE" --timeout=5m
            echo "✅ $APP_NAME 部署完成"
          else
            echo "⚠️  Deployment 不存在: $DEPLOYMENT_NAME"
            echo "尝试从 YAML 文件创建 Deployment..."
            
            # 查找对应的 YAML 文件
            YAML_FILE=""
            # 检查单个应用的 YAML 文件
            if [ -f "k8s/deployments/$APP_NAME.yaml" ]; then
              YAML_FILE="k8s/deployments/$APP_NAME.yaml"
              echo "找到单个应用 YAML 文件: $YAML_FILE"
            # 检查 all-apps.yaml（包含多个应用）
            elif [ -f "k8s/deployments/all-apps.yaml" ]; then
              YAML_FILE="k8s/deployments/all-apps.yaml"
              echo "找到多应用 YAML 文件: $YAML_FILE"
            fi
            
            if [ -n "$YAML_FILE" ] && [ -f "$YAML_FILE" ]; then
              echo "创建 Deployment 并设置镜像: $FULL_IMAGE_TAG"
              
              # 创建临时 YAML 文件，替换镜像标签和命名空间
              TEMP_YAML=$(mktemp)
              cp "$YAML_FILE" "$TEMP_YAML"
              
              # 替换镜像标签（匹配包含应用名称的镜像行）
              sed -i "s|image:.*$APP_NAME.*|image: $FULL_IMAGE_TAG|g" "$TEMP_YAML"
              # 确保命名空间正确（替换所有 namespace 字段）
              sed -i "s|namespace:.*|namespace: $K8S_NAMESPACE|g" "$TEMP_YAML"
              
              # 应用 YAML 文件（kubectl apply 会自动只应用相关的资源）
              # 使用 --validate=false 跳过客户端验证，避免 OpenAPI schema 下载失败
              # 使用 --server-side 在服务器端应用，避免客户端验证问题
              echo "应用 YAML 文件..."
              kubectl apply -f "$TEMP_YAML" -n "$K8S_NAMESPACE" --validate=false --server-side || \
              kubectl apply -f "$TEMP_YAML" -n "$K8S_NAMESPACE" --validate=false
              
              # 等待 Deployment 就绪
              echo "等待 Deployment 就绪..."
              if kubectl wait --for=condition=available --timeout=5m deployment/"$DEPLOYMENT_NAME" -n "$K8S_NAMESPACE" 2>/dev/null; then
                echo "✅ Deployment 已就绪"
              else
                echo "⚠️  Deployment 创建成功，但可能尚未完全就绪"
              fi
              
              # 清理临时文件
              rm -f "$TEMP_YAML"
              
              echo "✅ $APP_NAME 部署完成（从 YAML 创建）"
            else
              echo "❌ 未找到 YAML 文件: k8s/deployments/$APP_NAME.yaml 或 k8s/deployments/all-apps.yaml"
              echo "请先创建 Deployment 或确保 YAML 文件存在"
              exit 1
            fi
          fi
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "✅ $APP_NAME 构建和部署成功"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

