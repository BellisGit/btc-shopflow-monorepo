name: Build & Deploy App (Reusable)

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
      app_dir:
        required: true
        type: string
      app_port:
        required: true
        type: string
      container_name:
        required: true
        type: string
      image_tag:
        required: true
        type: string
      registry:
        required: true
        type: string
    secrets:
      SERVER_HOST:
        required: false
      SERVER_USER:
        required: false
      SERVER_KEY:
        required: false
      SERVER_PORT:
        required: false
      SERVER_PAT:
        required: false

jobs:
  build-deploy-app:
    name: Build & Deploy ${{ inputs.app_name }}
    runs-on: ubuntu-latest

    env:
      APP_NAME: ${{ inputs.app_name }}
      APP_DIR: ${{ inputs.app_dir }}
      APP_PORT: ${{ inputs.app_port }}
      CONTAINER_NAME: ${{ inputs.container_name }}
      IMAGE_TAG: ${{ inputs.image_tag }}
      REGISTRY: ${{ inputs.registry }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Cache node_modules
        uses: actions/cache@v3
        with:
          path: |
            node_modules
            **/node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline

      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-

      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "ğŸ”¨ æ£€æŸ¥å¹¶æ„å»ºå…±äº«ä¾èµ–åŒ…ï¼ˆå¦‚æœç¼“å­˜æœªå‘½ä¸­ï¼‰..."
          echo "ğŸ“¦ æ„å»º @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true

          echo "ğŸ“¦ æ„å»º @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true

          echo "ğŸ“¦ æ„å»º @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true

          echo "ğŸ“¦ æ„å»º @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true

          echo "ğŸ“¦ æ„å»º @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true

      - name: Clean build artifacts
        run: |
          echo "ğŸ§¹ æ¸…ç† $APP_NAME çš„æ„å»ºäº§ç‰©..."
          rm -rf $APP_DIR/dist
          rm -rf $APP_DIR/build
          echo "âœ… æ¸…ç†å®Œæˆ"

      - name: Build ${{ inputs.app_name }}
        run: cd $APP_DIR && pnpm run build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1

      - name: Deploy ${{ inputs.app_name }}
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e

            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Starting BTC ShopFlow Deployment"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""

            echo "ğŸ” Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker

            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi

            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0

              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "ğŸ”„ å°è¯•ç™»å½•åˆ° $registry (ç¬¬ $retry_count/$max_retries æ¬¡)..."

                START_TIME=$(date +%s)

                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "âœ… ç™»å½•æˆåŠŸ (è€—æ—¶: ${ELAPSED} ç§’)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))

                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "â±ï¸  ç™»å½•è¶…æ—¶ (${timeout_seconds} ç§’)"
                  else
                    echo "âŒ ç™»å½•å¤±è´¥ (é€€å‡ºç : $EXIT_CODE, è€—æ—¶: ${ELAPSED} ç§’)"
                  fi

                  if [ $retry_count -lt $max_retries ]; then
                    echo "â³ ç­‰å¾… 3 ç§’åé‡è¯•..."
                    sleep 3
                  fi
                fi
              done

              return 1
            }

            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] æ— æ³•ç™»å½•åˆ° $REGISTRY"
              exit 1
            fi

            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0

              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "ğŸ”„ å°è¯•æ‹‰å–é•œåƒ (ç¬¬ $retry_count/$max_retries æ¬¡): $image"

                START_TIME=$(date +%s)

                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "âœ… é•œåƒæ‹‰å–æˆåŠŸ (è€—æ—¶: ${ELAPSED} ç§’)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))

                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "â±ï¸  æ‹‰å–è¶…æ—¶ (${timeout_seconds} ç§’)"
                  else
                    echo "âŒ æ‹‰å–å¤±è´¥ (é€€å‡ºç : $EXIT_CODE, è€—æ—¶: ${ELAPSED} ç§’)"
                  fi

                  if [ $retry_count -lt $max_retries ]; then
                    echo "â³ ç­‰å¾… 10 ç§’åé‡è¯•..."
                    sleep 10
                  fi
                fi
              done

              return 1
            }

            echo "ğŸ“¥ Pulling Docker image from $REGISTRY..."
            echo "ğŸ”„ å¼ºåˆ¶æ‹‰å–æœ€æ–°é•œåƒ: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true

            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "âš ï¸  æ— æ³•æ‹‰å– $IMAGE_NAME:$IMAGE_TAGï¼Œå°è¯• latest æ ‡ç­¾..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] æ— æ³•ä» $REGISTRY æ‹‰å–é•œåƒ"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi

            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "âœ… Image pulled and tagged successfully"

            echo "ğŸ”„ Updating container..."

            echo "ğŸ“‹ æ¸…ç†ç°æœ‰å®¹å™¨: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true

            echo "ğŸ” æ£€æŸ¥ç«¯å£ $PORT å ç”¨æƒ…å†µ..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "ğŸ›‘ åœæ­¢å®¹å™¨: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi

            echo "â³ ç­‰å¾…ç«¯å£ $PORT é‡Šæ”¾..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "âœ… ç«¯å£ $PORT å·²é‡Šæ”¾"
                break
              fi
              sleep 1
            done

            echo "ğŸŒ æ£€æŸ¥ Docker ç½‘ç»œ..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "ğŸ“¦ åˆ›å»º Docker ç½‘ç»œ: btc-network"
              docker network create btc-network || true
            fi

            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] é•œåƒä¸å­˜åœ¨: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi

            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"

            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] æœªæ‰¾åˆ° docker-compose æˆ– docker compose å‘½ä»¤"
              exit 1
            fi

            echo "ğŸš€ å¯åŠ¨æ–°å®¹å™¨..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] å®¹å™¨å¯åŠ¨å¤±è´¥"
              exit 1
            fi

            sleep 5

            echo "ğŸ” éªŒè¯å®¹å™¨çŠ¶æ€..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0

            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "âœ… å®¹å™¨æ­£åœ¨è¿è¡Œ"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done

            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] å®¹å™¨éªŒè¯è¶…æ—¶ï¼"
              exit 1
            fi

            echo "ğŸ§¹ Cleaning up unused images..."
            docker image prune -f || true

            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… Deployment completed!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

