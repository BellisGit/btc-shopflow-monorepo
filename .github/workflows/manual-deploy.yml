name: ğŸ¯ Manual Deploy

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'é€‰æ‹©è¦éƒ¨ç½²çš„åº”ç”¨ (ç”¨é€—å·åˆ†éš”ï¼Œæˆ–å¡«å†™ "all" éƒ¨ç½²æ‰€æœ‰åº”ç”¨)'
        required: true
        default: 'all'
        type: string
      environment:
        description: 'éƒ¨ç½²ç¯å¢ƒ'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_build:
        description: 'è·³è¿‡æ„å»ºï¼Œç›´æ¥éƒ¨ç½²ç°æœ‰é•œåƒ'
        required: false
        default: false
        type: boolean
      force_recreate:
        description: 'å¼ºåˆ¶é‡æ–°åˆ›å»ºPod'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  NAMESPACE: btc-shopflow

jobs:
  prepare:
    name: ğŸ”§ Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      apps-matrix: ${{ steps.apps.outputs.matrix }}
      should-build: ${{ steps.build.outputs.should-build }}
    
    steps:
    - name: ğŸ“‹ Parse applications
      id: apps
      run: |
        input_apps="${{ github.event.inputs.apps }}"
        
        if [ "$input_apps" == "all" ]; then
          apps='["system-app","admin-app","logistics-app","quality-app","production-app","engineering-app","finance-app","mobile-app"]'
        else
          # å°†é€—å·åˆ†éš”çš„å­—ç¬¦ä¸²è½¬æ¢ä¸ºJSONæ•°ç»„
          apps=$(echo "$input_apps" | sed 's/,/","/g' | sed 's/^/["/' | sed 's/$/"]/')
        fi
        
        echo "matrix=$apps" >> $GITHUB_OUTPUT
        echo "ğŸ“¦ Selected apps: $apps"

    - name: ğŸ—ï¸ Determine build requirement
      id: build
      run: |
        if [ "${{ github.event.inputs.skip_build }}" == "true" ]; then
          echo "should-build=false" >> $GITHUB_OUTPUT
          echo "â­ï¸ Skipping build, using existing images"
        else
          echo "should-build=true" >> $GITHUB_OUTPUT
          echo "ğŸ—ï¸ Will build new images"
        fi

  build:
    name: ğŸ—ï¸ Build Selected Apps
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should-build == 'true'
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        app: ${{ fromJson(needs.prepare.outputs.apps-matrix) }}
      fail-fast: false
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ³ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: ğŸ” Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: ğŸ“¦ Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8.15.0

    - name: ğŸ“¦ Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'pnpm'
        cache-dependency-path: 'pnpm-lock.yaml'

    - name: ğŸ“¥ Install dependencies
      run: pnpm install --no-frozen-lockfile

    - name: ğŸ—ï¸ Build ${{ matrix.app }}
      run: |
        echo "ğŸ—ï¸ Building ${{ matrix.app }}..."
        
        if [ ! -d "apps/${{ matrix.app }}" ]; then
          echo "âŒ App directory apps/${{ matrix.app }} does not exist"
          exit 1
        fi
        
        # ä½¿ç”¨æ„å»ºè„šæœ¬
        chmod +x scripts/build-all.sh
        
        # åˆ›å»ºä¸´æ—¶è„šæœ¬åªæ„å»ºæŒ‡å®šåº”ç”¨
        cat > build-single.sh << 'EOF'
        #!/bin/bash
        app_name=$1
        app_path="apps/${app_name}"
        
        if [ ! -f "${app_path}/Dockerfile" ]; then
          echo "ğŸ“ Creating Dockerfile for ${app_name}..."
          cat > "${app_path}/Dockerfile" << 'DOCKERFILE'
        FROM node:18-alpine as builder
        WORKDIR /app
        COPY package.json pnpm-lock.yaml pnpm-workspace.yaml ./
        COPY apps/ ./apps/
        COPY packages/ ./packages/
        COPY auth/ ./auth/
        RUN npm install -g pnpm
        RUN pnpm install --frozen-lockfile
        RUN cd apps/APP_NAME && pnpm run build
        FROM nginx:alpine
        COPY --from=builder /app/apps/APP_NAME/dist /usr/share/nginx/html
        RUN echo 'server { listen 80; location / { try_files $uri $uri/ /index.html; } }' > /etc/nginx/conf.d/default.conf
        EXPOSE 80
        CMD ["nginx", "-g", "daemon off;"]
        DOCKERFILE
          sed -i "s/APP_NAME/${app_name}/g" "${app_path}/Dockerfile"
        fi
        
        docker build -t btc-shopflow/${app_name}:latest -f ${app_path}/Dockerfile .
        EOF
        
        chmod +x build-single.sh
        ./build-single.sh ${{ matrix.app }}

    - name: ğŸ“¤ Push image
      run: |
        echo "ğŸ“¤ Pushing ${{ matrix.app }} to registry..."
        docker tag btc-shopflow/${{ matrix.app }}:latest ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.app }}:latest
        docker tag btc-shopflow/${{ matrix.app }}:latest ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.app }}:${{ github.sha }}
        docker push ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.app }}:latest
        docker push ${{ env.REGISTRY }}/${{ github.repository }}/${{ matrix.app }}:${{ github.sha }}

  deploy:
    name: ğŸš€ Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [prepare, build]
    if: always() && (needs.build.result == 'success' || needs.prepare.outputs.should-build == 'false')
    environment: 
      name: ${{ github.event.inputs.environment }}
      url: ${{ vars.APP_URL || 'https://btc-shopflow.com' }}
    
    steps:
    - name: ğŸ“¥ Checkout code
      uses: actions/checkout@v4

    - name: ğŸ” Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SERVER_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

    - name: ğŸ” Verify server connection
      run: |
        ssh -i ~/.ssh/id_rsa -p ${{ secrets.SERVER_PORT }} ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "echo 'Server connection successful'"

    - name: ğŸ“‹ Prepare namespace
      run: |
        if ! kubectl get namespace ${{ env.NAMESPACE }} &> /dev/null; then
          kubectl apply -f k8s/namespace.yaml
        fi
        kubectl apply -f k8s/configmap.yaml -n ${{ env.NAMESPACE }}

    - name: ğŸš€ Deploy applications
      run: |
        echo "ğŸš€ Deploying selected applications..."
        
        selected_apps='${{ needs.prepare.outputs.apps-matrix }}'
        echo "Selected apps: $selected_apps"
        
        # åº”ç”¨åŸºç¡€é…ç½®
        if [ -f "k8s/deployments/complete-apps.yaml" ]; then
          kubectl apply -f k8s/deployments/complete-apps.yaml -n ${{ env.NAMESPACE }}
        fi
        
        # æ›´æ–°æŒ‡å®šåº”ç”¨çš„é•œåƒ
        echo "$selected_apps" | jq -r '.[]' | while read app; do
          deployment_name="btc-$app"
          
          if [ "${{ needs.prepare.outputs.should-build }}" == "true" ]; then
            image_name="${{ env.REGISTRY }}/${{ github.repository }}/$app:${{ github.sha }}"
          else
            image_name="${{ env.REGISTRY }}/${{ github.repository }}/$app:latest"
          fi
          
          echo "ğŸ”„ Updating $deployment_name with image $image_name..."
          
          if kubectl get deployment "$deployment_name" -n ${{ env.NAMESPACE }} &> /dev/null; then
            kubectl set image deployment/"$deployment_name" "$app"="$image_name" -n ${{ env.NAMESPACE }}
            
            if [ "${{ github.event.inputs.force_recreate }}" == "true" ]; then
              echo "ğŸ”„ Force recreating pods for $deployment_name..."
              kubectl rollout restart deployment/"$deployment_name" -n ${{ env.NAMESPACE }}
            fi
          else
            echo "âš ï¸ Deployment $deployment_name not found"
          fi
        done

    - name: â³ Wait for deployment
      run: |
        echo "â³ Waiting for deployments to be ready..."
        
        selected_apps='${{ needs.prepare.outputs.apps-matrix }}'
        
        echo "$selected_apps" | jq -r '.[]' | while read app; do
          deployment_name="btc-$app"
          
          if kubectl get deployment "$deployment_name" -n ${{ env.NAMESPACE }} &> /dev/null; then
            echo "â³ Waiting for $deployment_name..."
            kubectl rollout status deployment/"$deployment_name" -n ${{ env.NAMESPACE }} --timeout=600s
          fi
        done

    - name: ğŸ” Verify deployment
      run: |
        echo "ğŸ” Deployment verification:"
        kubectl get deployments -n ${{ env.NAMESPACE }}
        kubectl get pods -n ${{ env.NAMESPACE }}
        kubectl get services -n ${{ env.NAMESPACE }}

    - name: ğŸ“Š Generate report
      run: |
        echo "## ğŸ¯ Manual Deployment Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment**: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Selected Apps**: ${{ github.event.inputs.apps }}" >> $GITHUB_STEP_SUMMARY
        echo "**Skip Build**: ${{ github.event.inputs.skip_build }}" >> $GITHUB_STEP_SUMMARY
        echo "**Force Recreate**: ${{ github.event.inputs.force_recreate }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### ğŸ“¦ Deployment Status:" >> $GITHUB_STEP_SUMMARY
        kubectl get deployments -n ${{ env.NAMESPACE }} --no-headers | while read line; do
          name=$(echo $line | awk '{print $1}')
          ready=$(echo $line | awk '{print $2}')
          echo "- **$name**: $ready" >> $GITHUB_STEP_SUMMARY
        done

  notify:
    name: ğŸ“¢ Notify Result
    runs-on: ubuntu-latest
    needs: [prepare, build, deploy]
    if: always()
    
    steps:
    - name: ğŸ“¢ Success notification
      if: needs.deploy.result == 'success'
      run: |
        echo "ğŸ‰ **Manual Deployment Successful!**"
        echo "âœ… Selected applications deployed successfully"
        echo "ğŸ¯ Apps: ${{ github.event.inputs.apps }}"
        echo "ğŸŒ Environment: ${{ github.event.inputs.environment }}"
        
    - name: ğŸ“¢ Failure notification
      if: needs.deploy.result == 'failure' || needs.build.result == 'failure'
      run: |
        echo "âŒ **Manual Deployment Failed!**"
        echo "ğŸ” Please check the logs for details"
        exit 1
