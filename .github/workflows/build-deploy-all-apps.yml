name: Build-Deploy All Apps

on:
  repository_dispatch:
    types: [build-deploy-all-apps]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  actions: write

jobs:
  detect-image-tag:
    name: Detect Image Tag
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.detect.outputs.image_tag }}
      repo_owner_lower: ${{ steps.detect.outputs.repo_owner_lower }}
      registry: ${{ steps.detect.outputs.registry }}
    steps:
      - name: Detect image tag and repository owner
        id: detect
        run: |
          echo "🔍 开始检测镜像标签和仓库信息..."
          echo "  - client_payload.github_sha: ${{ github.event.client_payload.github_sha }}"
          echo "  - github.sha: ${{ github.sha }}"
          
          # 转换仓库所有者名称为小写
          REPO_OWNER_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner_lower=$REPO_OWNER_LOWER" >> $GITHUB_OUTPUT
          echo "  ✅ 仓库所有者（小写）: $REPO_OWNER_LOWER"
          
          # 生成镜像标签（使用 SHA 前7位）
          if [ -n "${{ github.event.client_payload.github_sha }}" ]; then
            GIT_SHA="${{ github.event.client_payload.github_sha }}"
            echo "  ✅ 从 client_payload.github_sha 获取: $GIT_SHA"
          else
            GIT_SHA="${{ github.sha }}"
            echo "  ✅ 从 github.sha 获取: $GIT_SHA"
          fi
          
          if [ ${#GIT_SHA} -gt 7 ]; then
            IMAGE_TAG="${GIT_SHA:0:7}"
          elif [ ${#GIT_SHA} -lt 7 ]; then
            IMAGE_TAG="latest"
            echo "  ⚠️  SHA 太短，使用 latest"
          else
            IMAGE_TAG="$GIT_SHA"
          fi
          
          if [ -z "$IMAGE_TAG" ]; then
            echo "  ⚠️  标签为空，使用 latest"
            IMAGE_TAG="latest"
          fi
          
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "✅ 最终镜像标签: $IMAGE_TAG"
          
          # 检测镜像仓库（默认使用 ghcr.io）
          if [ -n "${{ secrets.PRIVATE_REGISTRY }}" ]; then
            REGISTRY="${{ secrets.PRIVATE_REGISTRY }}"
            echo "  ✅ 使用私有仓库: $REGISTRY"
          else
            REGISTRY="ghcr.io"
            echo "  ✅ 使用默认仓库: $REGISTRY"
          fi
          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT

  # 步骤1: 构建共享依赖（可选，失败不影响应用构建）
  build-shared-deps:
    name: Build Shared Dependencies
    needs: detect-image-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies
        continue-on-error: true
        run: |
          echo "🔨 构建共享依赖包..."
          echo "  这确保共享组件包（如 @btc/shared-components）的修改能够生效"
          echo ""
          
          # 始终重新构建共享依赖，确保修改生效
          # 使用 --force 确保即使缓存存在也重新构建
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build
          
          echo "✅ 共享依赖包构建完成"
      
      - name: Save built packages cache
        if: success() || failure()
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}

  # 步骤2: 每个应用独立构建和部署（8个并行Job）
  build-deploy-system-app:
    name: Build & Deploy system-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: system-app
      APP_DIR: apps/system-app
      APP_PORT: "30080"
      CONTAINER_NAME: btc-system-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build system-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Verify Dockerfile and build context
        run: |
          echo "🔍 验证 Dockerfile 和构建上下文..."
          echo "📋 检查 Dockerfile..."
          if [ ! -f "Dockerfile" ]; then
            echo "❌ 错误: Dockerfile 不存在"
            exit 1
          fi
          echo "✅ Dockerfile 存在"
          echo "📋 检查 Dockerfile 内容（前 10 行）..."
          head -10 Dockerfile
          echo ""
          echo "📋 检查 docker/nginx.conf..."
          if [ ! -f "docker/nginx.conf" ]; then
            echo "❌ 错误: docker/nginx.conf 不存在"
            exit 1
          fi
          echo "✅ docker/nginx.conf 存在"
          echo ""
          echo "📋 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ]; then
            echo "❌ 错误: ${{ env.APP_DIR }}/dist 不存在"
            exit 1
          fi
          echo "✅ ${{ env.APP_DIR }}/dist 存在"
          echo "📦 dist 目录内容:"
          ls -la ${{ env.APP_DIR }}/dist | head -10
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy system-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-admin-app:
    name: Build & Deploy admin-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: admin-app
      APP_DIR: apps/admin-app
      APP_PORT: "30081"
      CONTAINER_NAME: btc-admin-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build admin-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy admin-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-logistics-app:
    name: Build & Deploy logistics-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: logistics-app
      APP_DIR: apps/logistics-app
      APP_PORT: "30082"
      CONTAINER_NAME: btc-logistics-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build logistics-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy logistics-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-quality-app:
    name: Build & Deploy quality-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: quality-app
      APP_DIR: apps/quality-app
      APP_PORT: "30083"
      CONTAINER_NAME: btc-quality-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build quality-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy quality-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-production-app:
    name: Build & Deploy production-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: production-app
      APP_DIR: apps/production-app
      APP_PORT: "30084"
      CONTAINER_NAME: btc-production-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build production-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy production-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-engineering-app:
    name: Build & Deploy engineering-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: engineering-app
      APP_DIR: apps/engineering-app
      APP_PORT: "30085"
      CONTAINER_NAME: btc-engineering-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build engineering-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy engineering-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-finance-app:
    name: Build & Deploy finance-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: finance-app
      APP_DIR: apps/finance-app
      APP_PORT: "30086"
      CONTAINER_NAME: btc-finance-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build finance-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy finance-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  build-deploy-mobile-app:
    name: Build & Deploy mobile-app
    needs: [detect-image-tag, build-shared-deps]
    runs-on: ubuntu-latest
    env:
      APP_NAME: mobile-app
      APP_DIR: apps/mobile-app
      APP_PORT: "30091"
      CONTAINER_NAME: btc-mobile-app
      IMAGE_TAG: ${{ needs.detect-image-tag.outputs.image_tag }}
      REGISTRY: ${{ needs.detect-image-tag.outputs.registry }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
      
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Cache pnpm store
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: |
          pnpm install --frozen-lockfile --prefer-offline
      
      - name: Restore built packages cache
        uses: actions/cache@v3
        with:
          path: |
            packages/*/dist
            packages/*/build
          key: packages-build-${{ github.sha }}
          restore-keys: |
            packages-build-
      
      - name: Build shared dependencies (fallback)
        continue-on-error: true
        run: |
          echo "🔨 检查并构建共享依赖包（如果缓存未命中）..."
          echo "📦 构建 @btc/vite-plugin..."
          pnpm --filter @btc/vite-plugin run build --force || pnpm --filter @btc/vite-plugin run build || true
          
          echo "📦 构建 @btc/shared-utils..."
          pnpm --filter @btc/shared-utils run build --force || pnpm --filter @btc/shared-utils run build || true
          
          echo "📦 构建 @btc/shared-core..."
          pnpm --filter @btc/shared-core run build --force || pnpm --filter @btc/shared-core run build || true
          
          echo "📦 构建 @btc/shared-components..."
          pnpm --filter @btc/shared-components run build --force || pnpm --filter @btc/shared-components run build || true
          
          echo "📦 构建 @btc/subapp-manifests..."
          pnpm --filter @btc/subapp-manifests run build --force || pnpm --filter @btc/subapp-manifests run build || true
      
      - name: Clean build artifacts
        run: |
          echo "🧹 清理 ${{ env.APP_NAME }} 的构建产物..."
          rm -rf ${{ env.APP_DIR }}/dist
          rm -rf ${{ env.APP_DIR }}/build
          echo "✅ 清理完成"
      
      - name: Build mobile-app
        run: |
          echo "🔨 开始构建 ${{ env.APP_NAME }}..."
          cd ${{ env.APP_DIR }}
          echo "📂 当前目录: $(pwd)"
          echo "📋 检查 package.json..."
          if [ ! -f "package.json" ]; then
            echo "❌ 错误: package.json 不存在"
            exit 1
          fi
          echo "🚀 执行构建命令: pnpm run build"
          pnpm run build
          echo "✅ 构建命令执行完成"
          echo "📂 检查构建产物..."
          if [ -d "dist" ]; then
            echo "✅ dist 目录存在"
            ls -la dist | head -10
          else
            echo "❌ 错误: dist 目录不存在"
            exit 1
          fi
      
      - name: Verify build artifacts
        run: |
          echo "🔍 验证构建产物..."
          if [ ! -d "${{ env.APP_DIR }}/dist" ] || [ -z "$(ls -A ${{ env.APP_DIR }}/dist 2>/dev/null)" ]; then
            echo "❌ 错误: ${{ env.APP_NAME }} 的 dist 目录不存在或为空"
            echo "构建步骤可能失败了，请检查上面的构建日志"
            ls -la ${{ env.APP_DIR }}/ || true
            exit 1
          else
            echo "✅ 构建产物验证成功"
            echo "📦 dist 目录内容:"
            ls -la ${{ env.APP_DIR }}/dist | head -10
          fi
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ github.token }}
      
      - name: Prepare Docker tags
        id: tags
        run: |
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "repository_lower=$REPO_LOWER" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          build-args: |
            APP_DIR=${{ env.APP_DIR }}
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:latest
            ${{ env.REGISTRY }}/${{ steps.tags.outputs.repository_lower }}/${{ env.APP_NAME }}:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
        env:
          DOCKER_BUILDKIT: 1
      
      - name: Deploy mobile-app
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SERVER_KEY }}
          port: ${{ secrets.SERVER_PORT || '22' }}
          timeout: 1800s
          command_timeout: 20m
          script: |
            set -e
            
            APP_NAME="${{ env.APP_NAME }}"
            IMAGE_TAG="${{ env.IMAGE_TAG }}"
            PORT="${{ env.APP_PORT }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            REGISTRY="${{ env.REGISTRY }}"
            REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
            IMAGE_NAME="$REGISTRY/$REPO_LOWER/$APP_NAME"
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "🚀 Starting BTC ShopFlow Deployment"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "App: $APP_NAME"
            echo "Image: $IMAGE_NAME:$IMAGE_TAG"
            echo "Port: $PORT"
            echo ""
            
            echo "🔐 Logging into container registry..."
            mkdir -p /tmp/.docker
            export DOCKER_CONFIG=/tmp/.docker
            
            if [ -n "${{ secrets.SERVER_PAT }}" ]; then
              TOKEN="${{ secrets.SERVER_PAT }}"
            else
              TOKEN="${{ github.token }}"
            fi
            
            docker_login_with_timeout() {
              local registry=$1
              local username=$2
              local token=$3
              local timeout_seconds=${4:-30}
              local max_retries=${5:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试登录到 $registry (第 $retry_count/$max_retries 次)..."
                
                START_TIME=$(date +%s)
                
                if echo "$token" | timeout $timeout_seconds docker login "$registry" -u "$username" --password-stdin 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 登录成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  登录超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 登录失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 3 秒后重试..."
                    sleep 3
                  fi
                fi
              done
              
              return 1
            }
            
            if ! docker_login_with_timeout "$REGISTRY" "${{ github.actor }}" "$TOKEN" 30 3; then
              echo "[ERROR] 无法登录到 $REGISTRY"
              exit 1
            fi
            
            pull_image_with_timeout() {
              local image=$1
              local timeout_seconds=${2:-300}
              local max_retries=${3:-3}
              local retry_count=0
              
              while [ $retry_count -lt $max_retries ]; do
                retry_count=$((retry_count + 1))
                echo "🔄 尝试拉取镜像 (第 $retry_count/$max_retries 次): $image"
                
                START_TIME=$(date +%s)
                
                if timeout $timeout_seconds docker pull "$image" 2>&1; then
                  ELAPSED=$(($(date +%s) - START_TIME))
                  echo "✅ 镜像拉取成功 (耗时: ${ELAPSED} 秒)"
                  return 0
                else
                  EXIT_CODE=$?
                  ELAPSED=$(($(date +%s) - START_TIME))
                  
                  if [ $EXIT_CODE -eq 124 ]; then
                    echo "⏱️  拉取超时 (${timeout_seconds} 秒)"
                  else
                    echo "❌ 拉取失败 (退出码: $EXIT_CODE, 耗时: ${ELAPSED} 秒)"
                  fi
                  
                  if [ $retry_count -lt $max_retries ]; then
                    echo "⏳ 等待 10 秒后重试..."
                    sleep 10
                  fi
                fi
              done
              
              return 1
            }
            
            echo "📥 Pulling Docker image from $REGISTRY..."
            echo "🔄 强制拉取最新镜像: $IMAGE_NAME:$IMAGE_TAG"
            docker rmi "$IMAGE_NAME:$IMAGE_TAG" 2>/dev/null || true
            docker rmi "$IMAGE_NAME:latest" 2>/dev/null || true
            
            if ! pull_image_with_timeout "$IMAGE_NAME:$IMAGE_TAG" 300 3; then
              echo "⚠️  无法拉取 $IMAGE_NAME:$IMAGE_TAG，尝试 latest 标签..."
              if ! pull_image_with_timeout "$IMAGE_NAME:latest" 300 3; then
                echo "[ERROR] 无法从 $REGISTRY 拉取镜像"
                exit 1
              fi
              IMAGE_TAG="latest"
            fi
            
            docker tag "$IMAGE_NAME:$IMAGE_TAG" "btc-shopflow/$APP_NAME:latest" 2>/dev/null || true
            echo "✅ Image pulled and tagged successfully"
            
            echo "🔄 Updating container..."
            
            echo "📋 清理现有容器: $CONTAINER_NAME"
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            docker ps -a --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | xargs -r docker rm -f 2>/dev/null || true
            
            echo "🔍 检查端口 $PORT 占用情况..."
            PORT_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | awk '{print $1}' || true)
            if [ -n "$PORT_CONTAINERS" ]; then
              echo "$PORT_CONTAINERS" | while read -r container; do
                if [ -n "$container" ] && [ "$container" != "$CONTAINER_NAME" ]; then
                  echo "🛑 停止容器: $container"
                  docker stop "$container" 2>/dev/null || true
                  docker rm -f "$container" 2>/dev/null || true
                fi
              done
            fi
            
            echo "⏳ 等待端口 $PORT 释放..."
            for i in {1..10}; do
              ACTIVE_CONTAINERS=$(docker ps --format "{{.Names}}\t{{.Ports}}" | grep ":$PORT->" | wc -l || echo "0")
              if [ "$ACTIVE_CONTAINERS" = "0" ]; then
                echo "✅ 端口 $PORT 已释放"
                break
              fi
              sleep 1
            done
            
            echo "🌐 检查 Docker 网络..."
            if ! docker network inspect btc-network >/dev/null 2>&1; then
              echo "📦 创建 Docker 网络: btc-network"
              docker network create btc-network || true
            fi
            
            if ! docker images | grep -q "btc-shopflow/$APP_NAME.*latest"; then
              echo "[ERROR] 镜像不存在: btc-shopflow/$APP_NAME:latest"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose.${APP_NAME}.yml"
            {
              echo "version: '3.8'"
              echo "services:"
              echo "  $APP_NAME:"
              echo "    image: btc-shopflow/$APP_NAME:latest"
              echo "    container_name: $CONTAINER_NAME"
              echo "    ports:"
              echo "      - \"$PORT:80\""
              echo "    restart: unless-stopped"
              echo "    networks:"
              echo "      - btc-network"
              echo "networks:"
              echo "  btc-network:"
              echo "    external: true"
            } > "$COMPOSE_FILE"
            
            DOCKER_COMPOSE_CMD=""
            if command -v docker-compose >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              echo "[ERROR] 未找到 docker-compose 或 docker compose 命令"
              exit 1
            fi
            
            echo "🚀 启动新容器..."
            if ! $DOCKER_COMPOSE_CMD -f "$COMPOSE_FILE" up -d; then
              echo "[ERROR] 容器启动失败"
              exit 1
            fi
            
            sleep 5
            
            echo "🔍 验证容器状态..."
            CONTAINER_ID=""
            MAX_WAIT=30
            WAIT_INTERVAL=2
            ELAPSED=0
            
            while [ $ELAPSED -lt $MAX_WAIT ]; do
              CONTAINER_ID=$(docker ps --filter "name=^${CONTAINER_NAME}$" --format "{{.ID}}" 2>/dev/null | head -1 || echo "")
              if [ -n "$CONTAINER_ID" ]; then
                echo "✅ 容器正在运行"
                break
              fi
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
              sleep $WAIT_INTERVAL
            done
            
            if [ -z "$CONTAINER_ID" ]; then
              echo "[ERROR] 容器验证超时！"
              exit 1
            fi
            
            echo "🧹 Cleaning up unused images..."
            docker image prune -f || true
            
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            echo "✅ Deployment completed!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

  # 步骤3: 总结成功和失败的应用
  summary:
    name: Summary
    needs: 
      - detect-image-tag
      - build-deploy-system-app
      - build-deploy-admin-app
      - build-deploy-logistics-app
      - build-deploy-quality-app
      - build-deploy-production-app
      - build-deploy-engineering-app
      - build-deploy-finance-app
      - build-deploy-mobile-app
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      successful_apps: ${{ steps.collect.outputs.successful_apps }}
      failed_apps: ${{ steps.collect.outputs.failed_apps }}
      total_apps: ${{ steps.collect.outputs.total_apps }}
      success_count: ${{ steps.collect.outputs.success_count }}
      fail_count: ${{ steps.collect.outputs.fail_count }}
    steps:
      - name: Collect results
        id: collect
        run: |
          SUCCESSFUL_APPS=()
          FAILED_APPS=()
          
          echo "🔍 开始收集各应用的构建和部署结果..."
          
          # 直接读取每个job的结果
          check_app() {
            local app_name=$1
            local job_result=$2
            
            if [ -z "$job_result" ]; then
              job_result="unknown"
            fi
            
            echo "  $app_name: $job_result"
            
            if [ "$job_result" = "success" ]; then
              SUCCESSFUL_APPS+=("$app_name")
              echo "✅ $app_name: 构建和部署都成功"
            else
              FAILED_APPS+=("$app_name")
              echo "❌ $app_name: 状态 = $job_result"
            fi
          }
          
          check_app "system-app" "${{ needs.build-deploy-system-app.result }}"
          check_app "admin-app" "${{ needs.build-deploy-admin-app.result }}"
          check_app "logistics-app" "${{ needs.build-deploy-logistics-app.result }}"
          check_app "quality-app" "${{ needs.build-deploy-quality-app.result }}"
          check_app "production-app" "${{ needs.build-deploy-production-app.result }}"
          check_app "engineering-app" "${{ needs.build-deploy-engineering-app.result }}"
          check_app "finance-app" "${{ needs.build-deploy-finance-app.result }}"
          check_app "mobile-app" "${{ needs.build-deploy-mobile-app.result }}"
          
          APPS=("system-app" "admin-app" "logistics-app" "quality-app" "production-app" "engineering-app" "finance-app" "mobile-app")
          
          # 生成输出
          if [ ${#SUCCESSFUL_APPS[@]} -gt 0 ]; then
            SUCCESSFUL_APPS_STR=$(IFS=','; echo "${SUCCESSFUL_APPS[*]}")
            echo "successful_apps=$SUCCESSFUL_APPS_STR" >> $GITHUB_OUTPUT
          else
            echo "successful_apps=" >> $GITHUB_OUTPUT
          fi
          
          if [ ${#FAILED_APPS[@]} -gt 0 ]; then
            FAILED_APPS_STR=$(IFS=','; echo "${FAILED_APPS[*]}")
            echo "failed_apps=$FAILED_APPS_STR" >> $GITHUB_OUTPUT
          else
            echo "failed_apps=" >> $GITHUB_OUTPUT
          fi
          
          echo "total_apps=${#APPS[@]}" >> $GITHUB_OUTPUT
          echo "success_count=${#SUCCESSFUL_APPS[@]}" >> $GITHUB_OUTPUT
          echo "fail_count=${#FAILED_APPS[@]}" >> $GITHUB_OUTPUT
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "📊 构建和部署结果汇总"
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "总应用数: ${#APPS[@]}"
          echo "成功: ${#SUCCESSFUL_APPS[@]}"
          echo "失败: ${#FAILED_APPS[@]}"
          echo ""
          if [ ${#SUCCESSFUL_APPS[@]} -gt 0 ]; then
            echo "✅ 成功应用:"
            for app in "${SUCCESSFUL_APPS[@]}"; do
              echo "  - $app"
            done
          fi
          echo ""
          if [ ${#FAILED_APPS[@]} -gt 0 ]; then
            echo "❌ 失败应用:"
            for app in "${FAILED_APPS[@]}"; do
              echo "  - $app"
            done
          fi
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
      
      - name: Generate summary report
        run: |
          SUMMARY_TITLE="## 📊 构建和部署结果汇总"
          STATS_INFO="### 统计信息"
          TOTAL_APPS_COUNT="${{ steps.collect.outputs.total_apps }}"
          SUCCESS_COUNT_VAL="${{ steps.collect.outputs.success_count }}"
          FAIL_COUNT_VAL="${{ steps.collect.outputs.fail_count }}"
          
          SUCCESS_APPS_HEADER="### ✅ 成功应用"
          SUCCESSFUL_APPS_STR="${{ steps.collect.outputs.successful_apps }}"
          
          FAILED_APPS_HEADER="### ❌ 失败应用"
          FAILED_APPS_STR="${{ steps.collect.outputs.failed_apps }}"
          
          DETAIL_INFO_HEADER="### 📋 详细信息"
          IMAGE_TAG_VAL="${{ needs.detect-image-tag.outputs.image_tag }}"
          REGISTRY_VAL="${{ needs.detect-image-tag.outputs.registry }}"
          GIT_SHA_VAL="${{ github.sha }}"
          
          # 如果 detect-image-tag 失败，使用默认值
          if [ -z "$IMAGE_TAG_VAL" ]; then
            IMAGE_TAG_VAL="latest"
          fi
          if [ -z "$REGISTRY_VAL" ]; then
            REGISTRY_VAL="ghcr.io"
          fi
          
          {
            echo "$SUMMARY_TITLE"
            echo ""
            echo "$STATS_INFO"
            echo "- **总应用数**: $TOTAL_APPS_COUNT"
            echo "- **成功**: $SUCCESS_COUNT_VAL"
            echo "- **失败**: $FAIL_COUNT_VAL"
            echo ""
            
            if [ -n "$SUCCESSFUL_APPS_STR" ]; then
              echo "$SUCCESS_APPS_HEADER"
              IFS=',' read -ra APPS <<< "$SUCCESSFUL_APPS_STR"
              for app in "${APPS[@]}"; do
                echo "- \`$app\`"
              done
              echo ""
            fi
            
            if [ -n "$FAILED_APPS_STR" ]; then
              echo "$FAILED_APPS_HEADER"
              IFS=',' read -ra APPS <<< "$FAILED_APPS_STR"
              for app in "${APPS[@]}"; do
                echo "- \`$app\`"
              done
              echo ""
            fi
            
            echo "$DETAIL_INFO_HEADER"
            echo "- **镜像标签**: $IMAGE_TAG_VAL"
            echo "- **仓库**: $REGISTRY_VAL"
            echo "- **Git SHA**: $GIT_SHA_VAL"
          } >> $GITHUB_STEP_SUMMARY
